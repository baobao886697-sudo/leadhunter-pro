# LeadHunter Pro 充值系统安全审计报告

**审计日期:** 2026-02-05
**审计员:** Manus AI

## 1. 审计目标

本次审计旨在全面评估 LeadHunter Pro 积分充值系统的安全性，重点关注以下问题：

-   **积分篡改**：用户或管理员是否可以任意修改积分？
-   **金额伪造**：用户是否可以通过伪造支付金额来获取更多积分？
-   **中间人攻击**：通信过程是否安全，能否被窃听或篡改？

## 2. 审计发现与分析

### 2.1 订单创建流程

| 检查项 | 状态 | 分析 |
| --- | --- | --- |
| 价格计算 | ✅ 安全 | 积分与USDT的兑换比例、优惠策略均在**后端计算**，前端只传递期望充值的积分数量。 |
| 唯一金额 | ✅ 安全 | 系统通过在基础金额上增加唯一的随机尾数（0.01-0.99）来创建订单，有效防止了相同金额订单的混淆。 |
| 订单归属 | ✅ 安全 | 订单与用户ID绑定，用户只能查询自己的订单。 |

**结论**：订单创建流程安全，用户无法在客户端篡改充值金额或积分数量。`1 USDT` 获得 `10000` 积分的情况**不会发生**，因为最终获得的积分数由后端根据实际支付金额和优惠策略计算得出。

### 2.2 支付检测与确认机制

| 检查项 | 状态 | 分析 |
| --- | --- | --- |
| 支付网关 | ✅ 安全 | 系统通过轮询 TronGrid API 来获取真实的链上交易数据，不依赖任何用户端的回调。 |
| 金额匹配 | ⚠️ 中等风险 | 使用 `Math.abs(parseFloat(order.amount) - amount) < 0.001` 进行浮点数比较，存在极低概率的精度问题。 |
| 交易缓存 | ⚠️ 中等风险 | 已处理的交易ID存储在内存中的 `Set` 里，服务重启后会丢失，可能导致**重复处理**历史交易。 |
| 订单状态 | ✅ 安全 | 订单确认前会检查状态是否为 `pending`，防止重复确认。 |

**结论**：支付检测机制的核心逻辑是安全的，因为它依赖于可信的第三方API。但存在两个中等风险点需要改进。

### 2.3 积分发放与修改逻辑

| 检查项 | 状态 | 分析 |
| --- | --- | --- |
| 积分发放 | ✅ 安全 | 积分在订单被确认为 `paid` 后，在**后端**通过 `addCredits` 函数发放，用户无法干预。 |
| 管理员操作 | ✅ 安全 | 管理员修改用户积分的接口 (`adjustCredits`) 受 `adminProcedure` 保护，需要有效的管理员Token才能调用。 |
| 数据库事务 | 🟡 低风险 | 积分修改和日志记录并非在同一个数据库事务中完成，理论上存在不一致的可能，但实际发生概率极低。 |

**结论**：积分发放和修改逻辑是安全的，普通用户无法篡改自己的积分。所有关键操作都在后端完成，并有权限控制。

### 2.4 API 接口权限控制

| 检查项 | 状态 | 分析 |
| --- | --- | --- |
| 关键接口 | ✅ 安全 | 所有涉及资金和积分修改的API（如创建订单、确认订单、修改积分）都使用了 `protectedProcedure` 或 `adminProcedure` 进行保护，需要用户或管理员登录。 |
| 公开接口 | ✅ 安全 | 公开的接口（如获取充值配置）仅用于信息展示，不涉及敏感操作。 |

**结论**：API 权限控制严格，不存在越权操作的风险。

### 2.5 中间人攻击防护

| 检查项 | 状态 | 分析 |
| --- | --- | --- |
| 通信加密 | ✅ 安全 | 网站已启用 HTTPS，所有客户端与服务器之间的通信都经过 TLS 加密，可以有效防止中间人攻击。 |
| Cookie 安全 | ✅ 安全 | Session Cookie 设置了 `HttpOnly`、`Secure` 和 `SameSite` 属性，增强了对跨站脚本攻击（XSS）和跨站请求伪造（CSRF）的防护。 |

**结论**：系统具备良好的中间人攻击防护能力。

## 3. 总体安全评估与建议

LeadHunter Pro 的充值系统在核心设计上是**安全**的，有效防止了用户通过前端或抓包工具篡改充值金额和积分。您担心的“1USDT获得1w积分”等攻击场景**不会发生**。

尽管如此，我们还是识别出两个**中等风险**问题，建议在未来的版本中进行修复：

1.  **持久化交易缓存**：将已处理的交易ID（`processedTxIds`）从内存缓存迁移到数据库或 Redis 等持久化存储中，防止服务重启后重复确认订单。
2.  **精确金额匹配**：将浮点数比较改为整数或字符串比较，以完全消除精度问题。例如，可以将 USDT 金额乘以 100 或 1,000,000（取决于精度要求）后作为整数进行比较。

这些改进将进一步增强系统的健壮性和安全性。
