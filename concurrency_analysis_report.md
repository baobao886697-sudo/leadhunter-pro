# SPF 并发模式分析报告：并发模式 vs. 线程池+并发模式

## 1. Scrape.do 官方文档核心洞察

根据 Scrape.do 官方文档，其 **Async-API** 运行在**独立的后台线程池**中，与主 API 并发完全独立 [1]。这表明 Scrape.do 官方认为**线程池是处理大规模爬虫任务的最佳实践**。

> The **Async-API** runs in a **separate background thread pool** that's fully independent from your main API concurrency. [1]

## 2. 两种模式对比分析

| 特性 | 并发模式 (当前 SPF 实现) | 线程池+并发模式 (Scrape.do 推荐) |
|---|---|---|
| **实现方式** | 单线程 + 异步并发 | 多进程/多线程 + 异步并发 |
| **内存占用** | 低（共享内存） | 高（每个进程/线程独立内存） |
| **CPU 利用** | 单核（I/O 密集型足够） | 多核（CPU 密集型更好） |
| **复杂度** | 简单 | 复杂（需要进程间通信） |
| **适用场景** | **网络爬虫、API 调用**（I/O 密集） | 图像处理、计算（CPU 密集） |
| **故障隔离** | 一个任务出错可能影响其他 | 进程独立，互不影响 |

## 3. 哪一个更有优势？

**对于 SPF 爬虫场景，线程池+并发模式更有优势。**

**理由：**

1. **符合 Scrape.do 官方最佳实践**
   - Scrape.do 的 Async-API 明确使用了线程池模型，这证明了其在处理大规模爬虫任务时的有效性。

2. **更好的资源利用和隔离**
   - 虽然 SPF 是 I/O 密集型任务，但使用线程池可以更好地隔离不同任务，避免一个任务的异常影响整个系统。
   - 在多用户场景下，线程池可以更公平地分配资源，避免某个用户的大任务独占所有并发资源。

3. **更高的可扩展性**
   - 线程池模型更容易扩展，可以根据系统负载动态调整线程数量。
   - 为未来可能引入的 CPU 密集型任务（如数据清洗、分析）提供了基础。

4. **更强的稳定性**
   - 进程/线程级别的隔离可以防止单个任务的崩溃导致整个应用退出。

## 4. 建议

**短期建议：**

- **保持当前模式**：`TASK_CONCURRENCY = 3` + `GLOBAL_MAX_CONCURRENCY = 15`
- **理由**：当前模式简单可靠，能够满足现有需求，且修改成本低。

**长期建议：**

- **重构为线程池+并发模式**：使用 Node.js 的 `worker_threads` 模块
- **理由**：
  - 符合 Scrape.do 官方最佳实践
  - 提升系统稳定性和可扩展性
  - 为未来功能扩展提供更好的架构基础

**实施方案：**
1. 创建一个任务队列（如 Redis 或 BullMQ）
2. 创建一个包含 3 个 Worker Thread 的线程池
3. 每个 Worker Thread 从任务队列中获取任务并执行
4. 在 Worker Thread 内部，使用并发控制（如 `p-limit`）来限制对 Scrape.do 的并发请求数，并遵守全局 15 并发的限制。

## 5. 参考文献

[1] Scrape.do. (n.d.). *Asynchronous API | Documentation*. Retrieved from https://scrape.do/documentation/async-api/
